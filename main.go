package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/gorilla/mux"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"

	_ "./docs" // docs is generated by Swag CLI, you have to import it.

	httpSwagger "github.com/swaggo/http-swagger"
)

var db *gorm.DB

type BaseModel struct {
	ID        uint      `json:"id" gorm:"primaryKey"`
	CreatedAt time.Time `json:"createdAt" example:"2019-11-09T21:21:46+00:00"`
	UpdatedAt time.Time `json:"updatedAt" example:"2019-11-09T21:21:46+00:00"`
}

// Recipe represents the model for an recipe
type Recipe struct {
	BaseModel
	RecipeName string    `json:"recipeName" example:"Veal Scallopini"`
	Items      []RecItem `json:"items" `
}

// RecItem is an amount of ingredient for recipe
type RecItem struct {
	BaseModel
	RecipeID   uint       `json:"recipeId"`
	Ingredient Ingredient `json:"ingredient" gorm:"foreignkey:id"`
	Amount     string     `json:"amount" example:"3 oz"`
}

// Ingredient represents the model for an item in the recipe
type Ingredient struct {
	BaseModel
	Name        string `json:"name" example:"Swiss Cheese"`
	Description string `json:"description" example:"A random description"`
	State       string `json:"state" example:"powder"`
}

// CreateRecipe godoc
// @Summary Create a new recipe
// @Description Create a new recipe with the input paylod
// @Tags recipes
// @Accept  json
// @Produce  json
// @Param recipe body Recipe true "Create recipe"
// @Success 200 {object} Recipe
// @Router /recipes [post]
func createRecipe(w http.ResponseWriter, r *http.Request) {
	var recipe Recipe
	json.NewDecoder(r.Body).Decode(&recipe)
	// zero-out values that should not be user-set
	recipe.CreatedAt = time.Time{}
	recipe.UpdatedAt = time.Time{}

	db.Create(&recipe)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(recipe)
}

// GetRecipes godoc
// @Summary Get details of all recipes
// @Description Get details of all recipes
// @Tags recipes
// @Accept  json
// @Produce  json
// @Success 200 {array} Recipe
// @Router /recipes [get]
func getRecipes(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	var recipes []Recipe
	db.Preload("Recipes").Find(&recipes)
	json.NewEncoder(w).Encode(recipes)
}

func sanitizeInputID(valStr string) string {
	// TODO: ensure it's not sql-injection. - must be integer?
	return valStr
}

// GetRecipe godoc
// @Summary Get details for a given recipeId
// @Description Get details of recipe corresponding to the input recipeId
// @Tags recipes
// @Accept  json
// @Produce  json
// @Param recipeId path int true "ID of the recipe"
// @Success 200 {object} Recipe
// @Router /recipes/{recipeId} [get]
func getRecipe(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	params := mux.Vars(r)
	inputID := sanitizeInputID(params["recipeId"])

	var obj Recipe
	db.Preload("Recipes").First(&obj, inputID)

	json.NewEncoder(w).Encode(obj)
}

// UpdateRecipe godoc
// @Summary Update recipe identified by the given recipeId
// @Description Update the recipe corresponding to the input recipeId
// @Tags recipes
// @Accept  json
// @Produce  json
// @Param recipeId path int true "ID of the recipe to be updated"
// @Success 200 {object} Recipe
// @Router /recipes/{recipeId} [post]
func updateRecipe(w http.ResponseWriter, r *http.Request) {
	var obj Recipe
	json.NewDecoder(r.Body).Decode(&obj)
	db.Save(&obj)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(obj)
}

// DeleteRecipe godoc
// @Summary Delete recipe identified by the given recipeId
// @Description Delete the recipe corresponding to the input recipeId
// @Tags recipes
// @Accept  json
// @Produce  json
// @Param recipeId path int true "ID of the recipe to be deleted"
// @Success 204 "No Content"
// @Router /recipes/{recipeId} [delete]
func deleteRecipe(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	inputID := params["recipeId"]
	// Convert `inputId` string param to uint64
	id64, _ := strconv.ParseUint(inputID, 10, 64)
	// Convert uint64 to uint
	idToDelete := uint(id64)

	db.Where("recipe_id = ?", idToDelete).Delete(&RecItem{})
	db.Where("recipe_id = ?", idToDelete).Delete(&Recipe{})
	w.WriteHeader(http.StatusNoContent)
}

// CreateIngredient godoc
// @Summary Create a new ingredient
// @Description Create a new ingredient with the input paylod
// @Tags ingredients
// @Accept  json
// @Produce  json
// @Param ingredient body Ingredient true "Create ingredient"
// @Success 200 {object} Ingredient
// @Router /ingredients [post]
func createIngredient(w http.ResponseWriter, r *http.Request) {
	var obj Ingredient
	fmt.Println(r.Body)
	json.NewDecoder(r.Body).Decode(&obj)
	fmt.Println(obj)
	// zero-out values that should not be user-set
	obj.CreatedAt = time.Time{}
	obj.UpdatedAt = time.Time{}

	db.Create(&obj)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(obj)
}

// GetIngredient godoc
// @Summary Get details of all ingredients
// @Description Get details of all ingredients
// @Tags ingredients
// @Accept  json
// @Produce  json
// @Success 200 {array} Ingredient
// @Router /ingredients [get]
func getIngredients(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	items := []Ingredient{}
	result := db.Find(&items)
	if result.Error != nil {
		json.NewEncoder(w).Encode(items)
	} else {
		json.NewEncoder(w).Encode(items)
	}
}

// GetIngredient godoc
// @Summary Get details for a given ingredientId
// @Description Get details of recipe corresponding to the input ingredientId
// @Tags ingredients
// @Accept  json
// @Produce  json
// @Param ingredientId path int true "ID of the ingredient"
// @Success 200 {object} Ingredient
// @Router /ingredients/{ingredientId} [get]
func getIngredient(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	params := mux.Vars(r)
	inputID := sanitizeInputID(params["ingredientId"])

	var item Ingredient
	db.First(&item, inputID)
	json.NewEncoder(w).Encode(item)
}

// UpdateIngredient godoc
// @Summary Update ingredient identified by the given ingredientId
// @Description Update the ingredient corresponding to the input ingredientId
// @Tags ingredients
// @Accept  json
// @Produce  json
// @Param ingredientId path int true "ID of the ingredient to be updated"
// @Success 200 {object} Ingredient
// @Router /ingredients/{ingredientId} [post]
func updateIngredient(w http.ResponseWriter, r *http.Request) {
	var obj Ingredient
	json.NewDecoder(r.Body).Decode(&obj)
	db.Save(&obj)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(obj)
}

// DeleteIngredient godoc
// @Summary Delete ingredient identified by the given ingredientId
// @Description Delete the ingredient corresponding to the input ingredientId
// @Tags ingredients
// @Accept  json
// @Produce  json
// @Param ingredientId path int true "ID of the ingredient to be deleted"
// @Success 204 "No Content"
// @Router /ingredients/{ingredientId} [delete]
func deleteIngredient(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	inputID := params["ingredientId"]
	// Convert `inputId` string param to uint64
	id64, _ := strconv.ParseUint(inputID, 10, 64)
	// Convert uint64 to uint
	idToDelete := uint(id64)

	db.Where("ingredient_id = ?", idToDelete).Delete(&RecItem{})
	db.Where("ingredient_id = ?", idToDelete).Delete(&Ingredient{})
	// TODO: have to delete recipes that reference?

	w.WriteHeader(http.StatusNoContent)
}

// SearchIngredients godoc
// @Summary Search ingredients
// @Description Search the ingredients
// @Tags ingredients
// @Accept  json
// @Produce  json
// @Param q query string true "partial string to search"
// @Success 200 {array} Ingredient
// @Router /search/ingredients [get]
func searchIngredients(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	inputStr := params["q"]
	// TODO: sanitize inputStr

	var items []Ingredient

	q := fmt.Sprint("%", inputStr, "%")
	db.Where("name LIKE ?", q).Find(&items)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(items)
}

func initDB() {
	var err error
	//dataSourceName := "root:myrecips@tcp(localhost:3306)/?parseTime=True"
	//db, err = gorm.Open("mysql", dataSourceName)
	db, err = gorm.Open(sqlite.Open("recipes.db"), &gorm.Config{})
	if err != nil {
		fmt.Println(err)
		panic("failed to connect database")
	}

	// (MySQL) Create the database. This is a one-time step.
	// Comment out if running multiple times - You may see an error otherwise
	//db.Exec("CREATE DATABASE recip")
	//db.Exec("USE recip")

	// Migration to create tables for Recipe and Item schema
	db.AutoMigrate(&Recipe{}, &RecItem{}, &Ingredient{})

	//var items []Ingredient
	//db.Find(&items)
}

// @title Recipes API
// @version 1.0
// @description This is a sample serice for testing gorm with swagger
// @host localhost:8080
// @BasePath /
func main() {
	router := mux.NewRouter()
	// Create
	router.HandleFunc("/recipes", createRecipe).Methods("POST")
	// Read
	router.HandleFunc("/recipes/{recipeId}", getRecipe).Methods("GET")
	// Read-all
	router.HandleFunc("/recipes", getRecipes).Methods("GET")
	// Update
	router.HandleFunc("/recipes/{recipeId}", updateRecipe).Methods("PUT")
	// Delete
	router.HandleFunc("/recipes/{recipeId}", deleteRecipe).Methods("DELETE")

	// Create
	router.HandleFunc("/ingredients", createIngredient).Methods("POST")
	// Read
	router.HandleFunc("/ingredients/{ingredientId}", getIngredient).Methods("GET")
	// Read-all
	router.HandleFunc("/ingredients", getIngredients).Methods("GET")
	// Update
	router.HandleFunc("/ingredients/{ingredientId}", updateIngredient).Methods("PUT")
	// Delete
	router.HandleFunc("/ingredients/{ingredientId}", deleteIngredient).Methods("DELETE")

	// Create
	router.HandleFunc("/search/ingredients", searchIngredients).Queries("q", "{q}").Methods("GET")

	/*
		// Create
		router.HandleFunc("/recitems", createIngredient).Methods("POST")
		// Read
		router.HandleFunc("/recitems/{ingredientId}", getIngredient).Methods("GET")
		// Read-all
		router.HandleFunc("/recitems", getIngredients).Methods("GET")
		// Update
		router.HandleFunc("/recitems/{recItemId}", updateIngredient).Methods("PUT")
		// Delete
		router.HandleFunc("/recitems/{recItemId}", deleteIngredient).Methods("DELETE")
	*/

	// Initialize db connection
	initDB()

	// Swagger
	router.PathPrefix("/swagger").Handler(httpSwagger.WrapHandler)

	log.Fatal(http.ListenAndServe(":8080", router))
}
